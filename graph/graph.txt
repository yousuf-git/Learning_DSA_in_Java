-----------------Graph Data Structure----------------

    Cities Path in the form of graph:
        
        Multan ---- Lahore__    
       /                |   \
      Murree            |    Karachi ---- Islamabad
       \                |   /
        Peshawar ---- Quetta

-------------Vertex/Edge-------------------

There are 2 main things in graph:

- Vertex : Multan, Lahore, ... etc.
- Edge : (source, destination), like (Multan, Lahore) means path from multan to Lahore

-------------Directed/Undirected graphs-------------------

If there is specific direction to go from one vertex to other, then graph is called directed. Or if we can go to and from one vertex to other then graph is undirected

Directed => A --> B --> C --> A

Undirected => A -- B -- C -- A
    Can also be as => A <--> B <--> C <--> A (or bi-directional)

-------------Connected/Unconnected graphs-------------------

Suppose if I add (A,B) and (B,A) for all edges it means that graph is undirected, we can go in both directions

If all edges of graph are connected through some path then graph is connected and otherwise it is un-connected. Consider 2 separate graphs, these will be unconnected because not all edges are connected
Example:
    G1 : A -- B -- C
    G1 : D -- E

    G1 and G2 are individually connected graphs but if we see them both combined as a single graph then it is an unconnected graph

---------------------

Functions Performed on Graph:

1. Creating Graph - weighted / unwieghted 
2. Finding all neighbours of a vertex
3. BFS / DFS for connected and unconnected graph
4. Finding All Paths from source to destination
5. Topological Sorting
6. Cycle Detection for directed / undirected graphs

Graph can be Implemented by:

1. Adjacency List -> List of List
        I'll be creating Array[] of ArrayList, 
        where size of array will be No. Of Vertices

2. Adjacency Matrix -> A(n x n)
    where a(ij) = 1 if there is path from i to j, 0 otherwise

3. Edge List
    A single list containing all edges

4. 2D Matrix (Implicit Graph)

---------Implementation Structure-------------

ArrayList<Edge>[n] graph; // n is number of edges
HashMap<T, ArrayList<Edge>> graph; // keys are vertices and each vertex has an ArrayList that contains all edges directly connected to it

class Edge<Type, Type_2(if any)> {
    Type src;
    Type dest;
    Type_2 weight; // if graph is weighted
}

To Acceess all the neighbours of a vertex, we can directly access it by its index.
graph[vertexIdx] gives an ArrayList that contains exactly all its neighbours

for (Edge edge : ArrayList) {
    edge.src; // source vertex itself
    edge.dest; // neighbour
}

Time Complexity = O(n) where n is number of neighbours
which is quite low, thats why we use Adjacency List

-------------Graph Traversal--------------

- Depth First Search (DFS)
- Bredth First Search (BFS)

BFS:
    Also called Level Order Traversal
    Give Priority to immediate neighbours First
    Example:

        A --- B --- D --- E
        |           |     / 
        C --- F      \   /
                       G

    In this graph if we are applying BFS and choose A as start
    Suppose Step 1: A --> B then
    Before going from B --> D, First goto C

    I'll be using a queue and an array visited[] to Implement BFS on graph, that includes 3 steps
        1. Print current vertex
        2. Add All the neighbours of current vertex in queue
        3. Remove the current vertex and mark it as visited
    
    Time Complexity O (V+E) 
        if V is very large => O(V)
        if E is very large => O(E)

    Example Graph:

        1 ---- 3    
       /       | \
      0        |   5 ---- 6
       \       | /
        2 ---- 4
    
    BFS should result in : 0 1 2 3 4 5 6

DFS:
    DFS should result in : 0 1 3 4 2 5 6



----------------------Topological Sorting----------------------

- Applicable for DAG (Directed Acyclic Graph)
- For every vertex (u,v), in topological sorted order u should come before v
- Linear Time Complexity O(n)
- Not unique, there can be many topological sorted orders

Example: Directed Graph V(G) = { (B,A), (B,D), (A,D), (D,C) }
            A
          / |
        B   |   C
            v  /
            D

Topological Sort: B, A, D, C
                  B, D, A, C      // wrong because A comes before D in edge (A, D)

Can be done by BFS / DFS, I'm doing by DFS here

----------Steps-------------

1. Start visiting the univisited edges one by one and apply DFS
2. When there is no neighbour left, put the current vertex into a common stack
3. At the end when all vertices are visited, pop all elements from the stack

Time Complexity = O (V + E)

----------------Cycle Detection---------------

1. For Undirected Graph
    - DFS / BFS
    - DSU (Disjoint Graph Union)


2. For Directed Graph
    - DFS / BFS
    - Topological Sort (Kahn's Algorithm)

